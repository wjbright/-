import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'
import designSystem from './planetaria-design-system.png'

export const article = {
  author: 'Bright Williams',
  date: '2024-01-28',
  title: 'My thoughts on TRPC',
  description:
    'An AI-generated article as a placeholder for technical articles to be written later',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

tRPC, short for TypeScript RPC, is a modern development tool designed for building typesafe APIs easily. 
It leverages TypeScript to enable end-to-end type safety from the client to the server, 
eliminating the need for manual type definitions. 

<Image src={designSystem} alt="" />

To get started with tRPC, you first need a basic understanding of TypeScript and Node.js. 
Installation involves setting up a new Node.js project and installing tRPC and its dependencies. 
Developers can then define procedures on the server and use them on the client with automatic type inference. 

## Setup and Installation

tRPC's simplicity and type safety make it a popular choice for developers looking to streamline their API development process. 
For detailed guidance,the official [tRPC documentation](https://trpc.io/) offers comprehensive resources and examples.


```js
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import { z } from 'zod';
import { db } from './db.js';
import { publicProcedure, router } from './trpc.js';

const appRouter = router({
  userList: publicProcedure.query(async () => {
    // Retrieve users from a datasource, this is an imaginary database
    const users = await db.user.findMany();
    //    ^?
    return users;
  }),
  userById: publicProcedure.input(z.string()).query(async (opts) => {
    const { input } = opts;
    //      ^?
    // Retrieve the user with the given ID
    const user = await db.user.findById(input);
    return user;
  }),
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) => {
      const { input } = opts;
      //      ^?
      // Create a new user in the database
      const user = await db.user.create(input);
      //    ^?
      return user;
    }),
});

// Export type router type signature,
// NOT the router itself.
export type AppRouter = typeof appRouter;

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);
```

## Advantages of TRPC
The advantages of tRPC (TypeScript RPC) include:

1. End-to-End Type Safety: tRPC ensures type safety across the entire stack, from the server to the client, significantly reducing the risk of runtime errors related to data types.

2. No Code Generation: Unlike some other tools, tRPC doesn't require code generation for types. Types are inferred automatically, simplifying the development process.

3. Simplified Data Fetching: tRPC allows developers to call server-side functions directly from the client, streamlining data fetching without the need for REST or GraphQL APIs.

4. Enhanced Developer Experience: With TypeScript integration, tRPC offers a better developer experience, including features like auto-completion and refactoring capabilities.

5. Reduced Boilerplate: By eliminating the need for manual type definitions and API routes, tRPC cuts down on boilerplate code, making the codebase cleaner and more maintainable.

6. Flexible and Lightweight: tRPC is adaptable to various use cases and works seamlessly with existing tools and frameworks in the TypeScript ecosystem. It's also lightweight, adding minimal overhead to projects.


These benefits make tRPC a powerful tool for TypeScript developers seeking efficiency and reliability in building APIs.
